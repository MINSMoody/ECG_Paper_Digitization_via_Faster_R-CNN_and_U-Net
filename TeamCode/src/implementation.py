
from TeamCode.src.interface import AbstractDigitizationModel, AbstractClassificationModel
from TeamCode.src.verify_environment import verify_environment
import helper_code as hc
import numpy as np

class VoidClassificationModel(AbstractClassificationModel):
    def __init__(self):
        pass

    @classmethod
    def from_folder(cls, model_folder, verbose):
        return cls()

    def train_model(self, data_folder, model_folder, verbose):
        pass

    def run_classification_model(self, record, signal, verbose):
        return None
    

class OurDigitizationModel(AbstractDigitizationModel):
    def __init__(self):
        verify_environment()

    def train_model(self, data_folder, model_folder, verbose):
        print("We did not implement training the digitization model from (Image, Signal) pairs. Since we need extra context information generated by ecg-toolkit for training.")
        pass

    @classmethod
    def from_folder(cls, model_folder, verbose):
        # load whatever is in the model folder of this git repo
        # TODO
        return cls()
    
    def run_digitization_model(self, record, verbose):
        header_file = hc.get_header_file(record)
        header = hc.load_text(header_file)

        num_samples = hc.get_num_samples(header)
        num_signals = hc.get_num_signals(header)

        images = hc.load_images(record)
        # I think there can be more than one image per record

        if verbose:
            print(f'Running the digitization model on {record}, it has {len(images)} images.')

        signal_collector = np.zeros((len(images), num_samples, num_signals))
        for i, img in enumerate(images):
            # img is a PIL object at this point

            np_img = np.asarray(img)



            if verbose:
                print(f'Image shape: {np_img.shape}')

            seed = int(np.round(np.mean(img)))

            this_signal = np.random.default_rng(seed=seed).uniform(low=-0.1, high=0.1, size=(num_samples, num_signals))
            signal_collector[i, :, :] = this_signal
        
        signal = np.mean(signal_collector, axis=0)
        return signal
        